apiVersion: batch/v1
kind: Job
metadata:
  # Must have a real name (Kustomize requires metadata.name).
  name: release-errata
  # Argo CD annotations for PostSync Job that gets removed before each sync
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    argocd.argoproj.io/wave: "1"
spec:
  ttlSecondsAfterFinished: 100
  template:
    spec:
      volumes:
      - name: payload
        configMap:
          name: payload
      containers:
      - name: release-errata
        image: quay.io/redhat-user-workloads/ocp-virt-images-tenant/pipeline-tools
        workingDir: /tmp
        envFrom:
          - configMapRef:
              name: release-config
          - secretRef:
              name: stone-prd-rh01
        volumeMounts:
        - name: payload
          mountPath: /tmp
        args:
        - /bin/bash
        - '-c'
        - |
          set -eux

          CHANNEL="$(yq '.channel' payload.yaml)" && echo "CHANNEL --> ${CHANNEL}"
          HCO_BUNDLE_VERSION="$(yq '.hco_bundle_version' payload.yaml)" && echo "HCO_BUNDLE_VERSION --> ${HCO_BUNDLE_VERSION}"
          RELEASEPLAN="$(yq '.releasePlan' payload.yaml)" && echo "RELEASEPLAN --> ${RELEASEPLAN}"

          ERRATA_URL='https://errata.devel.redhat.com'
          CURL_OPTS="--user ':' --negotiate --retry 5 --retry-delay 2 --retry-connrefused"
          RETRIES=40
          WAIT_TIME=300

          ######################
          # TODO: Errata login #
          ######################

          errata_wait_for_status () {
            count=0

            while [[ $count -lt $RETRIES ]]; do
              errata_state=$(errata_get_state $1)
              if [[ "$errata_state" = "$2" ]]
              then
                return 0
              fi

              count=$((count+1))

              if [[ $count -lt $RETRIES ]]; then
                echo "Advisory $1 still in $errata_state , retrying in $WAIT_TIME seconds..."
                sleep "$WAIT_TIME"
              fi
            done
            echo "Timeouting the wait for status process."
            exit 1
          }

          errata_get_state () {
            status=$(curl $CURL_OPTS "${ERRATA_URL}/api/v1/erratum/${1}" | jq -r '.errata.rhea.status')
            echo "${status}"
          }

          errata_get_advisory_by_bundle () {
            advisory_id=$(curl $CURL_OPTS "${ERRATA_URL}/api/v1/build/hco-bundle-registry-container-$1" | jq -r '.all_errata[0].id')
            if [[ "$advisory_id" == "null" ]]
            then
              echo "Unable to find an advisory with bundle attached"
              exit 1
            fi
            echo "${advisory_id}"
          }

          errata_change_state () {
            curl $CURL_OPTS -d "new_state=$2" -X POST "${ERRATA_URL}/api/v1/erratum/${1}/change_state"
            errata_wait_for_status $1 $2
          }

          errata_ship_live () {
            echo "Changing errata $1 advisory state to REL_PREP"
            curl $CURL_OPTS -d "new_state=REL_PREP" -X POST "${ERRATA_URL}/api/v1/erratum/${1}/change_state"
            errata_wait_for_status $1 "SHIPPED_LIVE"
          }

          if [[ "$CHANNEL" != "stable" || "$RELEASEPLAN" != "prod" ]]; then
            echo "CHANNEL is not stable or RELEASEPLAN is not prod, skipping errata step"
            exit 0
          fi

          ADVISORY_ID=$(errata_get_advisory_by_bundle "${HCO_BUNDLE_VERSION}")

          # Get advisory status
          ADVISORY_STATUS=$(errata_get_state "${ADVISORY_ID}")
          if [[ "$ADVISORY_STATUS" == "NEW_FILES" ]]
          then
            echo "Changing errata $ADVISORY_ID advisory state to QE"
            errata_change_state $ADVISORY_ID "QE"
          fi

          errata_ship_live "${ADVISORY_ID}"
      restartPolicy: Never